## JavaScript闭包

闭包（closure）是 Javascript 语言的一个难点，面试时常被问及，也是它的特色，
很多高级应用都要依靠闭包实现。本文尽可能用简单易懂的话，讲清楚闭包的概念、形成条件及其常见的面试题。

```js
var n = 999
function f1() {
  console.log(n)
}
f1()

function f2() {
  var m = 888
}
console.log(m) // ReferenceError: m is not defined
```

上面代码中，f1()内部可以读取全局变量 n, 但是 f2()函数外部无法读取函数内部声明的变量 m

如果有时需要得到函数内部的局部变量。正常情况下，这是办不到的。只有通过变通的方法才能实现。
那就是在函数内部，再定义一个函数。

```js
function f1() {
  var n = 999
  function f2() {
    console.log(n)
  }
}
```
上面代码中，函数 f2() 就在 f1() 内部, 此时 f1 内部的所有局部变量， 对f2 都是可见的。
只要把f2 作为返回值，就可以在f1() 外部读取它的内部变量了。

### 1. 什么是闭包

```js
function f1() {
  var a = 999
  function f2() {
    console.log(a)
  }
  return f2  // f1 返回了 f2的引用
}
var result = f1()  // result 就是 f2 函数了
result()
// 执行result, 全局作用域下没有定义 a
// 但是f2函数是闭包，能把定义函数时候的作用域一起记住
```

闭包就是函数`f2()`, 即能够读取其他函数内部变量的函数。由于在JS中，只有函数内部的子函数
才能读取内部变量，因此可以把闭包简单理解成 '定义在一个函数内部的函数'。**闭包最大的特点，就是它可以记住诞生的环境，比如 f2 记住了它的诞生环境 f1, 所以f2可以得到f1的内部变量**
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

**当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这就产生了闭包**。 ----《你不知道的Javascript上卷》

我个人理解，**闭包就是函数中的函数(其他语言不能函数再套函数)**,里面的函数可以访问外面函数的变量，外面的变量的是这个内部函数的一部分。

闭包形成的条件
* 函数嵌套
* 内部函数引用外部函数的局部变量


### 2. 闭包的特性

**每个函数都是闭包，每个函数天生都能够记忆自己定义时所处的作用域环境。**
把一个函数从它定义的那个作用域，挪走，运行。这个函数居然能够记忆住定义时的那个作用域。
不管函数走到哪里，定义时的作用域就带到了哪里。接下来我们用两个例子来说明这个问题：

```js
var inner
function outer() {
  var a = 250
  inner = function() {
    console.log(a)  // 这个函数虽然在外部执行，但能够记忆住定义时的那个作用域，a是 250
  }
}
outer()
var a = 300
inner() // 输出:250，一个函数在执行时，找闭包里面的变量，不会理会当前作用域
```

```js
function outer(x) {
  function inner(y) {
    console.log(x + y)
  }
  return inner
}
var inn = outer(3) // 数字3传入outer(), inner函数中的 x 便会记住这个值
inn(5) // 输出8 当inner 函数再传入5, 只会对 y 赋值，最后输出 8
```

### 3. 闭包的内存泄漏

栈内存提供一个执行环境，即作用域，包括全局作用域和私有作用域，那么它们什么时候释放内存呢？

* **全局作用域----只有当页面关闭的时候全局作用域才会销毁**
* **私有作用域----只有当函数执行时才会产生**

**一般情况下，函数执行会形成一个新的私有作用域，当私有作用域的代码执行完之后，当前作用域都会主动的进行销毁和释放。但是当遇到函数执行返回了一个引用类型的值，并且在函数外被一个其他东西接收了，一般这种情况下形成的私有作用域都不会主动销毁。**

```js
function fn() {
  var num = 100
  // 返回一个引用类型的值，形成闭包
  return function() {
  }
}
var f = fn()  // fn() 执行形成的这个私有作用域就不能再被销毁
```

以上代码，fn() 私有作用域就会被一直占用，发生内存泄漏。
**内存泄漏是指，任何对象在您不再拥有或需要它之后任然存在。闭包不能滥用，否则导致内存泄漏，影响网页性能。闭包使用完之后，要立即释放资源，将引用变量指向null。**



### 4. 闭包的作用


### 5.闭包的运用


### 参考：
[深入浅出Javascript闭包](https://github.com/ljianshu/Blog/issues/6)