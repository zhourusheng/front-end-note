# 类

传统的 JavaScript 程序使用函数和基于原型的继承来创建可重复的组件。
从 ECMAScript 2015，也就是 ES6 开始， JavaScript 程序员将能够使用基于类 class 的面向对象的方式。

## 示例

```ts
// 声明一个 Greeter 类，这个类有三个成员：greeting 属性、constructor 构造函数、greet 方法
// 引用任何一个类成员都用了 this，表示我们访问的是类的成员
class Greeter {
  greeting: string
  constructor(message: string) {
    this.greeting = message
  }
  greet() {
    return `Hello,${this.greeting}`
  }
}
// 使用 new 构造了一个 Greeter 实例
let greeter = new Greeter('zhourusheng')
```

ts 转义之后的 JS 代码

```js
var Greeter = /** @class */ (function() {
  function Greeter(message) {
    this.greeting = message
  }
  Greeter.prototype.greet = function() {
    return 'Hello,' + this.greeting
  }
  return Greeter
})()
var greeter = new Greeter('zhourusheng')
console.log(greeter)
```

## 继承 extends

```ts
class Animal {
  move(distance: number = 0) {
    console.log(`Animal moved ${distance}m.`)
  }
}

class Dog extends Animal {
  bark() {
    console.log('Woof! Woof!')
  }
}

const dog = new Dog()
dog.bark()  // Woof! Woof!
dog.move(10)  // Animal moved 10m.
```

`Dog` 是一个 派生类，它派生自 `Animal` 基类，通过 `extends` 关键字。 派生类通常被称作 *子类*，基类通常被称作 *超类*。

```ts
class Animal {
  name: string
  constructor(name: string) {
    this.name = name
  }
  move(distance: number = 0) {
    console.log(`${this.name} moved ${distance}m.`)
  }
}

/**
 * 使用 extends 关键字创建了 Animal (基类) 的两个子类：Horse 和 Snake （派生类）
 * 这两个派生类各自包含一个 构造函数，它必须调用 super() , 它会执行 基类 的构造函数
 * 而且在 构造函数 里访问 this 的属性之前，一定要 调用 super(). 这是 TS 强制执行的一条重要规则
 * */ 

class Snake extends Animal {

  constructor(name: string) {
    super(name) // 必须调用super() 否则会报错：派生类的构造函数必须包含 "super" 调用。
  }
  move(distance: number = 5) {
    console.log('Slithering...')
    super.move(distance)
  }
}

class House extends Animal {
  constructor(name: string) {
    super(name)
  }
  // 重写了从 Animal 继承来的 move 方法，使得 move 方法根据不同的类而具有不同的功能
  move(distance: number = 45) {
    console.log('Galloping...')
    super.move(distance)
  }
}

let sam = new Snake('Sammy')
// 即使 tom 被声明为 Animal 类型，但因为它的值是 Horse，调用 tom.move(34) 时，它会调用 Horse 里重写的方法。
let tom: Animal = new House('Tommy')

sam.move()
//Slithering...
// Sammy moved 5m.

tom.move(34)
// Galloping...
// Tommy moved 34m
```

## 公有，私有与保护修饰符

### 默认为 pubilc

### 理解 private

### 理解 protected

## readonly 修饰符

### 参数属性

## 存取器

## 静态属性

## 抽象类

## 高级技巧

### 构造函数

### 把类当做接口使用
